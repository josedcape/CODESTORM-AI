@app.route('/api/process_natural', methods=['POST'])
def process_natural_command():
    """Process natural language input and return corresponding command."""
    try:
        data = request.json
        text = data.get('text', '')
        user_id = data.get('user_id', 'default')

        if not text:
            return jsonify({
                'success': False,
                'error': 'No se proporcionó texto'
            }), 400

        command = process_request(text)

        # Si se generó un comando, verificamos si es un comando que modifica archivos
        if command:
            # Lista de comandos que modifican el sistema de archivos
            file_modifying_commands = ['mkdir', 'touch', 'rm', 'cp', 'mv', 'ls']

            # Verificar si el comando es uno que modifica archivos
            is_file_command = any(cmd in command for cmd in file_modifying_commands)

            # Ejecutar el comando real en el sistema
            try:
                workspace_dir = get_user_workspace(user_id)
                current_dir = os.getcwd()
                os.chdir(workspace_dir)
                
                result = subprocess.run(
                    command,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                
                os.chdir(current_dir)
                
                command_output = result.stdout if result.returncode == 0 else result.stderr
                command_success = result.returncode == 0
            except Exception as cmd_error:
                logging.error(f"Error al ejecutar comando: {str(cmd_error)}")
                command_output = f"Error: {str(cmd_error)}"
                command_success = False
            
            # Si es un comando de archivos, enviar notificación por WebSocket
            if is_file_command:
                # Determinar el tipo de cambio
                change_type = 'unknown'
                file_path = ''

                if 'mkdir' in command:
                    change_type = 'create'
                    file_path = command.split('mkdir ')[1].strip()
                elif 'touch' in command:
                    change_type = 'create'
                    file_path = command.split('touch ')[1].strip()
                elif 'rm' in command:
                    change_type = 'delete'
                    parts = command.split('rm ')
                    if len(parts) > 1:
                        file_path = parts[1].replace('-rf', '').strip()

                # Enviar múltiples notificaciones para garantizar la actualización
                try:
                    # Notificación específica del cambio
                    socketio.emit('file_change', {
                        'type': change_type,
                        'file': {'path': file_path},
                        'timestamp': time.time()
                    }, broadcast=True)
                    
                    # Notificación genérica de actualización
                    socketio.emit('file_sync', {
                        'refresh': True,
                        'timestamp': time.time()
                    }, broadcast=True)
                    
                    # Notificación para terminales
                    socketio.emit('file_command', {
                        'command': command,
                        'type': change_type,
                        'file': file_path,
                        'timestamp': time.time()
                    }, broadcast=True)
                    
                    # Notificación de comando ejecutado
                    socketio.emit('command_executed', {
                        'command': command,
                        'output': command_output,
                        'success': command_success,
                        'timestamp': time.time()
                    }, broadcast=True)

                    logging.info(f"Notificaciones de cambio enviadas: {change_type} - {file_path}")
                except Exception as ws_error:
                    logging.error(f"Error al enviar notificación WebSocket: {str(ws_error)}")

            return jsonify({
                'success': True,
                'command': command,
                'refresh_explorer': is_file_command,
                'output': command_output,
                'success': command_success
            })
        else:
            return jsonify({
                'success': False,
                'error': 'No se pudo generar un comando para esa instrucción'
            }), 400

    except Exception as e:
        logging.error(f"Error processing natural language: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500
