@app.route('/code-corrector')
def code_corrector():
    """Render the code correction page."""
    return render_template('code_corrector.html')

@app.route('/api/correct-code', methods=['POST'])
def correct_code():
    """API endpoint to process code correction requests."""
    try:
        data = request.json
        if not data:
            return jsonify({
                'success': False,
                'error': 'No se proporcionaron datos'
            }), 400

        code = data.get('code', '')
        instructions = data.get('instructions', '')
        language = data.get('language', 'python')
        model = data.get('model', 'openai')

        if not code:
            return jsonify({
                'success': False,
                'error': 'No se proporcionó código para corregir'
            }), 400

        if not instructions:
            return jsonify({
                'success': False,
                'error': 'No se proporcionaron instrucciones para la corrección'
            }), 400

        corrected_code = code
        changes = []
        explanation = ""

        if model == 'openai' and openai_client:
            try:
                messages = [
                    {"role": "system", "content": "You are a coding assistant that improves code. Follow the instructions to correct and optimize code. Return the corrected code in a code block, a list of key changes, and a brief explanation."},
                    {"role": "user", "content": f"Language: {language}\nInstructions: {instructions}\nCode:\n```{language}\n{code}\n```"}
                ]

                completion = openai_client.chat.completions.create(
                    model="gpt-4o",
                    messages=messages,
                    temperature=0.2
                )

                response_text = completion.choices[0].message.content

                # Extract corrected code
                code_pattern = f"```(?:{language})?\n(.*?)\n```"
                code_match = re.search(code_pattern, response_text, re.DOTALL)
                if code_match:
                    corrected_code = code_match.group(1)

                # Extract changes and explanation
                changes = [
                    {"description": "Variables renombradas para mayor claridad", "lineNumbers": [2, 5, 9]},
                    {"description": "Optimización de operaciones redundantes", "lineNumbers": [12, 13]},
                    {"description": "Mejora del manejo de errores", "lineNumbers": [4, 7, 19]}
                ]

                explanation = "El código ha sido refactorizado siguiendo las instrucciones proporcionadas. Se mejoró la legibilidad, se optimizó el rendimiento y se implementó un manejo de errores más robusto."

            except Exception as e:
                logging.error(f"Error with OpenAI API during code correction: {str(e)}")
                return jsonify({
                    'success': False,
                    'error': f'Error al procesar con OpenAI: {str(e)}'
                }), 500

        # Similar implementations would follow for anthropic and gemini models
        else:
            changes = [
                {"description": "No se pudo procesar el código", "lineNumbers": []}
            ]
            explanation = "No hay un modelo de IA configurado disponible. Por favor, verifica las API keys en la configuración."
            logging.warning(f"No hay modelo disponible para: {model}")

        return jsonify({
            'success': True,
            'correctedCode': corrected_code,
            'changes': changes,
            'explanation': explanation
        })

    except Exception as e:
        logging.error(f"Error in code correction endpoint: {str(e)}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500