<!DOCTYPE html>
<html lang="es" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal Avanzada - Codestorm</title>

    <!-- Bootstrap y CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">

    <!-- xterm.js y dependencias -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.1.0/css/xterm.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.1.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.7.0/lib/xterm-addon-fit.min.js"></script>

    <!-- Socket.IO -->
    <script src="https://cdn.socket.io/4.6.0/socket.io.min.js"></script>

    <!-- Yjs para colaboración en tiempo real -->
    <script src="https://unpkg.com/yjs@13.5.0/dist/yjs.js"></script>
    <script src="https://unpkg.com/y-websocket@1.4.0/dist/y-websocket.js"></script>

    <!-- Estilos CSS (mantener los que ya estaban) -->
    <style>
        /* Mantener los estilos existentes */
        /* ... */
    </style>
</head>
<body>
    <!-- Mantener la estructura HTML existente -->
    <!-- ... -->

    <!-- Agregar un div para notificaciones -->
    <div id="notifications" class="notifications"></div>

    <!-- Cargar el procesador de comandos naturales -->
    <script src="{{ url_for('static', filename='js/natural-command-processor.js') }}"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Inicializar el procesador de comandos naturales
            const naturalCommandProcessor = new NaturalCommandProcessor();

            // Inicializar xterm.js
            const terminal = new Terminal({
                cursorBlink: true,
                theme: {
                    background: '#121212',
                    foreground: '#f0f0f0',
                    cursor: '#ffffff'
                },
                fontSize: 14,
                fontFamily: 'Menlo, Monaco, "Courier New", monospace',
                scrollback: 1000,
                convertEol: true
            });

            const fitAddon = new FitAddon.FitAddon();
            terminal.loadAddon(fitAddon);

            // Montar terminal en el contenedor
            const terminalContainer = document.getElementById('terminal-container');
            terminal.open(terminalContainer);
            fitAddon.fit();

            // Ajustar tamaño cuando cambia la ventana
            window.addEventListener('resize', () => {
                fitAddon.fit();
            });

            // Conectar con Socket.IO
            const socket = io();
            let connected = false;
            let currentDirectory = '.';
            let userId = 'default';
            let terminalId = generateTerminalId();

            // Generar ID único para la terminal
            function generateTerminalId() {
                return 'terminal-' + Math.random().toString(36).substring(2, 11);
            }

            // Actualizar indicador de estado
            function updateStatusIndicator(status) {
                const indicator = document.getElementById('status-indicator');
                if (!indicator) return;

                indicator.className = 'status-indicator';

                switch (status) {
                    case 'connected':
                        indicator.classList.add('status-connected');
                        indicator.title = 'Conectado';
                        connected = true;
                        break;
                    case 'disconnected':
                        indicator.classList.add('status-disconnected');
                        indicator.title = 'Desconectado';
                        connected = false;
                        break;
                    case 'connecting':
                        indicator.classList.add('status-connecting');
                        indicator.title = 'Conectando...';
                        connected = false;
                        break;
                }
            }

            // Mostrar notificación
            function showNotification(message, type = 'info') {
                const notificationsContainer = document.getElementById('notifications');
                const notification = document.createElement('div');
                notification.className = `notification notification-${type}`;
                notification.textContent = message;
                notificationsContainer.appendChild(notification);

                // Eliminar notificación después de 5 segundos
                setTimeout(() => {
                    notification.remove();
                }, 5000);
            }

            // Escribir en la terminal
            function writeToTerminal(text, color = null) {
                if (color) {
                    terminal.write(`\x1b[${color}m${text}\x1b[0m`);
                } else {
                    terminal.write(text);
                }
            }

            // Ejecutar comando
            function executeCommand(command) {
                if (!command) return;

                if (!connected) {
                    writeToTerminal('\r\n\x1b[31mError: No hay conexión con el servidor\x1b[0m\r\n');
                    writeToTerminal('\r\n$ ');
                    return;
                }

                // Enviar comando al servidor
                socket.emit('execute_command', {
                    command: command,
                    user_id: userId,
                    terminal_id: terminalId
                });

                // Limpiar la entrada después de enviar
                document.getElementById('terminal-input').value = '';
            }

            // Procesar entrada (puede ser comando directo o lenguaje natural)
            function processInput() {
                const inputElement = document.getElementById('terminal-input');
                const input = inputElement.value.trim();

                if (!input) return;

                // Escribir el comando en la terminal
                writeToTerminal('\r\n$ ' + input + '\r\n');

                // Si comienza con !, es un comando directo
                if (input.startsWith('!')) {
                    const directCommand = input.substring(1).trim();
                    executeCommand(directCommand);
                    return;
                }

                // Intentar procesar como lenguaje natural
                const result = naturalCommandProcessor.processInstruction(input, currentDirectory);

                if (result.success && result.command) {
                    // Es un comando válido, ejecutarlo
                    writeToTerminal(`\x1b[36mInterpretando: ${result.command}\x1b[0m\r\n`);
                    executeCommand(result.command);
                } else {
                    // No se pudo interpretar, intentar enviar al servidor para procesamiento
                    fetch('/api/process_natural', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            text: input,
                            user_id: userId
                        })
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success && data.command) {
                            writeToTerminal(`\x1b[36mComando generado: ${data.command}\x1b[0m\r\n`);
                            executeCommand(data.command);
                        } else {
                            writeToTerminal('\x1b[33mNo se pudo interpretar como comando. Tratando como consulta al asistente...\x1b[0m\r\n');

                            // Redirigir al usuario al asistente con la consulta
                            const assistantUrl = `/assistant?query=${encodeURIComponent(input)}`;
                            writeToTerminal(`\x1b[33mPuedes abrir el asistente para responder esta consulta: \x1b[34m${assistantUrl}\x1b[0m\r\n`);

                            // Mostrar el prompt de nuevo
                            writeToTerminal('\r\n$ ');
                        }
                    })
                    .catch(error => {
                        console.error('Error:', error);
                        writeToTerminal(`\x1b[31mError al procesar el comando: ${error.message}\x1b[0m\r\n`);
                        writeToTerminal('\r\n$ ');
                    });
                }
            }

            // Configurar eventos de Socket.IO
            socket.on('connect', () => {
                updateStatusIndicator('connected');
                writeToTerminal('\r\n\x1b[32mConectado al servidor\x1b[0m\r\n');
                writeToTerminal('\r\nBienvenido a la Terminal Avanzada de Codestorm.\r\n');
                writeToTerminal('Puedes escribir comandos directamente o usar lenguaje natural.\r\n');
                writeToTerminal('Ejemplo: "crea una carpeta llamada proyectos" o "!mkdir proyectos"\r\n\r\n');
                writeToTerminal('$ ');

                // Cargar archivos iniciales
                loadFiles();
            });

            socket.on('disconnect', () => {
                updateStatusIndicator('disconnected');
                writeToTerminal('\r\n\x1b[31mDesconectado del servidor\x1b[0m\r\n');
            });

            socket.on('command_result', (data) => {
                if (data.terminal_id === terminalId) {
                    if (data.output) {
                        writeToTerminal(data.output);
                    }

                    if (!data.success) {
                        writeToTerminal('\r\n\x1b[31mEl comando falló con código de error\x1b[0m\r\n');
                    }

                    writeToTerminal('\r\n$ ');

                    // Si el comando podría haber modificado archivos, actualizar explorador
                    if (data.command && (
                        data.command.includes('mkdir') || 
                        data.command.includes('touch') || 
                        data.command.includes('rm') || 
                        data.command.includes('mv') || 
                        data.command.includes('cp')
                    )) {
                        loadFiles();
                    }
                }
            });

            socket.on('file_system_changed', (data) => {
                loadFiles();
            });

            socket.on('server_info', (data) => {
                console.log('Información del servidor:', data);
            });

            // Cargar archivos en el explorador
            function loadFiles(directory = '.') {
                currentDirectory = directory;

                fetch(`/api/files?directory=${encodeURIComponent(directory)}&user_id=${userId}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            updateFileExplorer(data);
                        } else {
                            showNotification(data.error || 'Error al cargar archivos', 'error');
                        }
                    })
                    .catch(error => {
                        console.error('Error al cargar archivos:', error);
                        showNotification('Error al cargar archivos', 'error');
                    });
            }

            // Actualizar explorador de archivos
            function updateFileExplorer(data) {
                const explorerContent = document.querySelector('.explorer-content');
                if (!explorerContent) return;

                // Actualizar ruta actual
                const pathDisplay = document.getElementById('current-path');
                if (pathDisplay) {
                    pathDisplay.textContent = data.directory === '.' ? '/' : data.directory;
                }

                // Limpiar contenido actual
                explorerContent.innerHTML = '';

                // Agregar opción para subir un nivel si no estamos en la raíz
                if (data.directory !== '.') {
                    const upDir = document.createElement('div');
                    upDir.className = 'file-item';
                    upDir.innerHTML = '<i class="bi bi-arrow-up-circle icon"></i> ..';
                    upDir.addEventListener('click', () => {
                        const parentDir = data.directory.split('/').slice(0, -1).join('/') || '.';
                        loadFiles(parentDir);
                    });
                    explorerContent.appendChild(upDir);
                }

                // Separar directorios y archivos
                const directories = data.files.filter(f => f.type === 'directory');
                const files = data.files.filter(f => f.type === 'file');

                // Ordenar alfabéticamente
                directories.sort((a, b) => a.name.localeCompare(b.name));
                files.sort((a, b) => a.name.localeCompare(b.name));

                // Agregar directorios
                directories.forEach(dir => {
                    const dirElement = document.createElement('div');
                    dirElement.className = 'file-item directory';
                    dirElement.innerHTML = `<i class="bi bi-folder-fill icon"></i> ${dir.name}`;
                    dirElement.addEventListener('click', () => {
                        loadFiles(dir.path);
                    });
                    explorerContent.appendChild(dirElement);
                });

                // Agregar archivos
                files.forEach(file => {
                    const fileElement = document.createElement('div');
                    fileElement.className = 'file-item';

                    // Determinar icono según extensión
                    let icon = 'bi-file-earmark';
                    const ext = file.extension || '';

                    if (['html', 'htm'].includes(ext)) icon = 'bi-file-earmark-code';
                    else if (['js', 'ts'].includes(ext)) icon = 'bi-filetype-js';
                    else if (['css', 'scss'].includes(ext)) icon = 'bi-filetype-css';
                    else if (['py'].includes(ext)) icon = 'bi-filetype-py';
                    else if (['jpg', 'jpeg', 'png', 'gif'].includes(ext)) icon = 'bi-file-earmark-image';
                    else if (['md'].includes(ext)) icon = 'bi-file-earmark-text';

                    fileElement.innerHTML = `<i class="bi ${icon} icon"></i> ${file.name}`;
                    fileElement.addEventListener('click', () => {
                        // Abrir archivo en editor
                        window.location.href = `/edit_file?path=${encodeURIComponent(file.path)}&user_id=${userId}`;
                    });
                    explorerContent.appendChild(fileElement);
                });

                // Mostrar mensaje si no hay archivos
                if (data.files.length === 0) {
                    const emptyMessage = document.createElement('div');
                    emptyMessage.className = 'text-muted text-center p-3';
                    emptyMessage.textContent = 'No hay archivos en este directorio';
                    explorerContent.appendChild(emptyMessage);
                }
            }

            // Configurar eventos de UI

            // Botón de envío
            document.getElementById('send-button').addEventListener('click', processInput);

            // Entrada por teclado
            document.getElementById('terminal-input').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    processInput();
                }
            });

            // Botón para limpiar terminal
            document.getElementById('clear-button').addEventListener('click', function() {
                terminal.clear();
                writeToTerminal('$ ');
            });

            // Botón para alternar explorador en móvil
            const toggleExplorerButton = document.getElementById('toggle-explorer');
            if (toggleExplorerButton) {
                toggleExplorerButton.addEventListener('click', function() {
                    const explorerPanel = document.querySelector('.explorer-panel');
                    if (explorerPanel) {
                        explorerPanel.classList.toggle('d-none');
                    }
                });
            }

            // Inicializar estado
            updateStatusIndicator('connecting');

            // Enfoque inicial en la entrada
            document.getElementById('terminal-input').focus();
        });
    </script>
</body>
</html>
